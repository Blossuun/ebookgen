"""Finalize stage for publishing output artifacts and report."""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone
import json
from pathlib import Path
import shutil


@dataclass(frozen=True)
class FinalizeResult:
    """Paths generated by finalization."""

    output_pdf: Path
    output_txt: Path
    report_json: Path


def _select_best_pdf(stage_dir: Path) -> Path:
    for name in ("optimized.pdf", "ocr.pdf", "raw.pdf"):
        candidate = stage_dir / name
        if candidate.exists():
            return candidate
    raise FileNotFoundError("No PDF artifact found under stage directory.")


def _file_size_mb(path: Path) -> float:
    return round(path.stat().st_size / (1024 * 1024), 3)


def finalize(
    book_dir: Path,
    title: str,
    total_pages: int,
    processing_time_sec: float,
    input_size_mb: float,
    settings: dict[str, object],
    covers: dict[str, int | None],
    ocr_failed_pages: list[int] | None = None,
) -> FinalizeResult:
    """Copy output files and generate report.json."""
    stage_dir = book_dir / "stage"
    out_dir = book_dir / "out"
    out_dir.mkdir(parents=True, exist_ok=True)

    source_pdf = _select_best_pdf(stage_dir)
    source_txt = stage_dir / "text.txt"
    if not source_txt.exists():
        source_txt.write_text("", encoding="utf-8")

    output_pdf = out_dir / "book.pdf"
    output_txt = out_dir / "book.txt"
    report_path = out_dir / "report.json"

    shutil.copy2(source_pdf, output_pdf)
    shutil.copy2(source_txt, output_txt)

    failed_pages = sorted(ocr_failed_pages or [])
    success_pages = max(0, total_pages - len(failed_pages))
    output_pdf_size_mb = _file_size_mb(output_pdf)
    output_txt_size_mb = _file_size_mb(output_txt)
    compression_ratio = round(output_pdf_size_mb / input_size_mb, 3) if input_size_mb else 0.0

    report_payload = {
        "title": title,
        "total_pages": total_pages,
        "ocr_success_pages": success_pages,
        "ocr_failed_pages": failed_pages,
        "processing_time_sec": round(processing_time_sec, 2),
        "input_size_mb": round(input_size_mb, 3),
        "output_pdf_size_mb": output_pdf_size_mb,
        "output_txt_size_mb": output_txt_size_mb,
        "compression_ratio": compression_ratio,
        "settings": settings,
        "covers": covers,
        "created_at": datetime.now(timezone.utc).isoformat(),
    }
    report_path.write_text(json.dumps(report_payload, ensure_ascii=False, indent=2), encoding="utf-8")

    return FinalizeResult(output_pdf=output_pdf, output_txt=output_txt, report_json=report_path)

