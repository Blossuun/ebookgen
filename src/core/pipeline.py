"""Stage orchestration for Sprint 1 conversion pipeline."""

from __future__ import annotations

from dataclasses import asdict, dataclass
import json
from pathlib import Path
import shutil
import time
from uuid import uuid4

from core.assembler import assemble
from core.finalizer import FinalizeResult, finalize
from core.ocr import OCRResult, run_ocr
from core.optimizer import optimize_pdf
from core.validator import ValidationResult, validate

STAGE_NAMES = ("validate", "assemble", "ocr", "optimize", "finalize")


@dataclass(frozen=True)
class PipelineSettings:
    """User-facing conversion settings."""

    language: str = "kor+eng"
    optimize_mode: str = "basic"
    error_policy: str = "skip"
    front_cover: int | None = None
    back_cover: int | None = None


@dataclass(frozen=True)
class PipelineResult:
    """Artifacts generated by a successful pipeline run."""

    book_id: str
    book_dir: Path
    manifest_path: Path
    output_pdf: Path
    output_txt: Path
    report_json: Path


def _stage_state() -> dict[str, str]:
    return {stage: "pending" for stage in STAGE_NAMES}


def _manifest_payload(book_id: str, title: str, settings: PipelineSettings) -> dict[str, object]:
    return {
        "book_id": book_id,
        "title": title,
        "current_stage": "validate",
        "stages": _stage_state(),
        "settings": asdict(settings),
    }


def _write_manifest(manifest_path: Path, payload: dict[str, object]) -> None:
    manifest_path.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")


def _update_stage(manifest_path: Path, stage: str, status: str) -> None:
    payload = json.loads(manifest_path.read_text(encoding="utf-8"))
    payload["current_stage"] = stage
    payload["stages"][stage] = status
    _write_manifest(manifest_path, payload)


def _prepare_book_directory(book_dir: Path) -> None:
    (book_dir / "input").mkdir(parents=True, exist_ok=True)
    (book_dir / "stage").mkdir(parents=True, exist_ok=True)
    (book_dir / "out").mkdir(parents=True, exist_ok=True)


def _copy_input_files(validation: ValidationResult, input_dir: Path) -> None:
    for file_path in validation.files:
        shutil.copy2(file_path, input_dir / file_path.name)


def run_pipeline(
    input_dir: Path,
    workspace_dir: Path = Path("workspace/books"),
    settings: PipelineSettings | None = None,
    book_id: str | None = None,
) -> PipelineResult:
    """Run all conversion stages end-to-end and return output paths."""
    config = settings or PipelineSettings()
    resolved_input_dir = input_dir.resolve()
    resolved_book_id = book_id or uuid4().hex[:12]
    book_dir = workspace_dir.resolve() / resolved_book_id
    manifest_path = book_dir / "manifest.json"
    title = resolved_input_dir.name

    validation = validate(resolved_input_dir)
    _prepare_book_directory(book_dir)
    _copy_input_files(validation, book_dir / "input")

    manifest = _manifest_payload(book_id=resolved_book_id, title=title, settings=config)
    _write_manifest(manifest_path, manifest)

    start_time = time.perf_counter()
    current_stage = "validate"

    try:
        _update_stage(manifest_path, "validate", "running")
        _update_stage(manifest_path, "validate", "done")

        current_stage = "assemble"
        _update_stage(manifest_path, current_stage, "running")
        raw_pdf = assemble(
            book_dir / "input",
            book_dir / "stage",
            front_cover=config.front_cover,
            back_cover=config.back_cover,
        )
        _update_stage(manifest_path, current_stage, "done")

        current_stage = "ocr"
        _update_stage(manifest_path, current_stage, "running")
        ocr_result: OCRResult = run_ocr(
            raw_pdf=raw_pdf,
            ocr_pdf=book_dir / "stage" / "ocr.pdf",
            sidecar_text=book_dir / "stage" / "text.txt",
            language=config.language,
            error_policy=config.error_policy,
        )
        _update_stage(manifest_path, current_stage, "done")

        current_stage = "optimize"
        _update_stage(manifest_path, current_stage, "running")
        optimize_pdf(
            ocr_pdf=book_dir / "stage" / "ocr.pdf",
            optimized_pdf=book_dir / "stage" / "optimized.pdf",
            mode=config.optimize_mode,
        )
        _update_stage(manifest_path, current_stage, "done")

        current_stage = "finalize"
        _update_stage(manifest_path, current_stage, "running")
        finalize_result: FinalizeResult = finalize(
            book_dir=book_dir,
            title=title,
            total_pages=validation.total_pages,
            processing_time_sec=time.perf_counter() - start_time,
            input_size_mb=validation.total_size_mb,
            settings={
                "ocr_language": config.language,
                "optimize_mode": config.optimize_mode,
                "error_policy": config.error_policy,
            },
            covers={"front": config.front_cover, "back": config.back_cover},
            ocr_failed_pages=ocr_result.failed_pages,
        )
        _update_stage(manifest_path, current_stage, "done")

        return PipelineResult(
            book_id=resolved_book_id,
            book_dir=book_dir,
            manifest_path=manifest_path,
            output_pdf=finalize_result.output_pdf,
            output_txt=finalize_result.output_txt,
            report_json=finalize_result.report_json,
        )
    except Exception:
        if manifest_path.exists():
            _update_stage(manifest_path, current_stage, "failed")
        raise

